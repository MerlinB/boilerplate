import "util.scrypt";

/**
* A non-fungible token enforced by miners at layer 1
*/
contract SPVToken {
    // prevTx: tx being spent by the current tx
    // prevPrevTx: tx being spent by prevTx
    public function rotateKey(Sig signature, PubKey nextKey, SigHashPreimage txPreimage, bytes prevTx, bytes prevPrevTx) {
        // constants
        int TxIdLen = 32;
        int IdentityKeyLength = TxIdLen;
        int PrevTxIdIdx = 5; // txid position in tx hex
        int UnlockingScriptIdx = 41;
        // uninitialized token ID
        bytes NullIdentityKey = num2bin(0, IdentityKeyLength);

        SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.SINGLE | SigHash.FORKID;
        require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

        // read previous locking script: codePart + OP_RETURN + tokenID + ownerPublicKey
        bytes lockingScript = Util.scriptCode(txPreimage);
        int scriptLen = len(lockingScript);

        // constant part of locking script: upto OP_RETURN
        int constStart = scriptLen - IdentityKeyLength - Util.PubKeyLen;
        bytes constPart = lockingScript[ : constStart];

        PubKey prevKey = PubKey(lockingScript[constStart + IdentityKeyLength : ]);
        // authorize
        require(checkSig(signature, prevKey));

        bytes outpoint = Util.outpoint(txPreimage);
        bytes prevTxId = outpoint[ : IdentityKeyLength];
        require(hash256(prevTx) == prevTxId);

        bytes identityKey = lockingScript[constStart : constStart + IdentityKeyLength];

        if (identityKey == NullIdentityKey) {
            // get prevTxId and use it to initialize identityKey
            identityKey = prevTxId;
        } else {
            /*
            * validate not only the parent tx (prevTx), but also its parent tx (prevPrevTx)
            */

            // TODO: assume 1 input, to extend to multiple inputs
            bytes prevPrevTxId = prevTx[PrevTxIdIdx : PrevTxIdIdx + TxIdLen];
            require(hash256(prevPrevTx) == prevPrevTxId);

            int unlockingScriptLen = Util.readVarintLen(prevPrevTx[UnlockingScriptIdx : ]);

            // TODO: only validate output 0 here, to extend to multiple outputs
            int lockingScriptIdx = UnlockingScriptIdx + unlockingScriptLen + Util.InputSeqLen + 1 /* output count length */ + Util.OutputValueLen;
            bytes prevLockingScript = Util.readVarint(prevPrevTx[lockingScriptIdx : ]);
            // ensure prev tx uses the same contract code
            require(len(prevLockingScript) == len(lockingScript));
            require(prevLockingScript[ : constStart] == constPart);
            // belongs to the same token
            bytes prevTokenId = prevLockingScript[constStart : constStart + IdentityKeyLength];
            require(prevTokenId == identityKey || prevTokenId == NullIdentityKey);
        }

        // validate parent tx
        bytes outputScript = constPart + identityKey + nextKey;

        int prevBalance = Util.value(txPreimage);
        bytes output = Util.buildOutput(outputScript, prevBalance);
        require(hash256(output) == Util.hashOutputs(txPreimage));
    }
}